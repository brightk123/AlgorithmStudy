## 1. BufferedReader

### 📌 설명

* 자바에서 **빠른 입력**을 위해 사용하는 클래스
* `Scanner`보다 속도가 훨씬 빠름 → 입력이 많은 경우 유리
* 입력은 항상 **문자열(String)** 형태로 반환

### 📌 기본 사용법

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String line = br.readLine(); // 한 줄 입력
int num = Integer.parseInt(line); // 문자열을 정수로 변환
```

### 📌 특징

* 장점: 많은 데이터를 빠르게 읽을 수 있음
* 단점: 입력 타입 변환 필요 (int, long 등)

---

## 2. BufferedWriter

### 📌 설명

* **빠른 출력**을 위해 사용하는 클래스
* `System.out.println`보다 속도가 좋음, 특히 반복 출력 시 유리
* 출력 버퍼를 사용하기 때문에 반드시 `flush()`로 버퍼를 비워야 함

### 📌 기본 사용법

```java
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
bw.write("Hello World\n"); // 문자열 출력
bw.flush();                 // 버퍼 비우기
bw.close();                 // 종료
```

### 📌 특징

* 장점: 많은 데이터를 효율적으로 출력 가능
* 단점: `flush()`를 안 하면 화면에 출력되지 않을 수 있음

---

## 3. StringBuilder

### 📌 설명

* 문자열을 **효율적으로 이어붙이기** 위해 사용
* 문자열을 반복해서 `+`로 연결하면 성능 저하가 발생 → StringBuilder 사용

### 📌 예시

```java
StringBuilder sb = new StringBuilder();
sb.append("Hello ");
sb.append("World");
System.out.println(sb.toString());
```

### 📌 특징

* 장점: 메모리 효율적, 속도 빠름
* 단점: 다중 스레드 환경에서는 안전하지 않음 → 필요 시 StringBuffer 사용

---

## 4. StringTokenizer

### 📌 설명

* 문자열을 **구분자 기준으로 나누어 토큰화**
* 주로 공백, 콤마 등으로 구분된 여러 입력값 처리에 사용

### 📌 예시

```java
StringTokenizer st = new StringTokenizer("1 2 3", " "); // 공백 기준
while (st.hasMoreTokens()) {
    System.out.println(st.nextToken());
}
```

### 📌 특징

* 장점: 간단하고 빠름
* 단점: 구분자 변경이 불편, 배열로 바로 받기 어려움

---

## 5. 이진 탐색 (Binary Search)

### 📌 핵심 아이디어

1. **정렬된 배열** 필요 (작은 수 → 큰 수)
2. 배열의 **가운데 값(mid)** 확인
3. 찾고 싶은 값(`target`)과 비교

   * target < mid → 왼쪽 구간 탐색
   * target > mid → 오른쪽 구간 탐색
   * target == mid → 찾음!
4. 범위를 **반씩 줄여가며 탐색** → 시간 복잡도 `O(log N)`

---

### 📌 예시

정렬된 배열:

```
[-10, 2, 3, 6, 10]
```

찾고 싶은 값: `6`

1. 처음 범위: 인덱스 0 \~ 4

   * 가운데(mid=2) 값 = 3
   * 6 > 3 → 오른쪽 범위(3\~4) 이동

2. 새로운 범위: 인덱스 3 \~ 4

   * 가운데(mid=3) 값 = 6
   * 6 == 6 → 찾았다!

✅ 단 2번만에 찾음 (N=5인데도 2번 비교)

---

### 📌 시간 복잡도

* 최악의 경우 확인 횟수 = `log₂N`
* 예: N = 1,000,000 → 약 20번 비교만으로 탐색 가능

---

### 📌 자바 구현 예시

```java
public static boolean binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;

    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) return true;      // 찾았다
        else if (arr[mid] < target) left = mid + 1;  // 오른쪽 이동
        else right = mid - 1;                        // 왼쪽 이동
    }
    return false; // 못 찾음
}
```

---

## 6. Arrays.binarySearch

### 📌 설명

* 자바에서 제공하는 **내장 이진 탐색 함수**
* 정렬된 배열에서 `key`가 있는지 확인 가능
* 반환값

  * `0 이상` → 존재, 반환값 = 인덱스
  * `음수` → 없음, `-(insertion point)-1`

---

### 📌 예시

```java
int[] arr = {-10, 2, 3, 6, 10};
System.out.println(Arrays.binarySearch(arr, 6));  // 3
System.out.println(Arrays.binarySearch(arr, 5));  // -4
```

* 존재 여부 판단:

```java
if (Arrays.binarySearch(arr, num) >= 0) {
    System.out.println("존재");
} else {
    System.out.println("없음");
}
```

---

### 📌 특징

* 장점: 직접 이진 탐색 구현 필요 없음, 코드가 짧음
* 단점: **배열이 정렬되어 있어야 사용 가능**

---
