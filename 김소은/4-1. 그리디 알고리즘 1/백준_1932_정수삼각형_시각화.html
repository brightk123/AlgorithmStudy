
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<title>정수 삼각형 DP 시각화 (트리 + 경로 강조)</title>
<style>
body { font-family: Arial, "Noto Sans KR", sans-serif; padding:20px; }
.grid { display:grid; grid-gap:5px; margin-bottom:10px; }
.cell { padding:6px 10px; border:1px solid #aaa; text-align:center; background:#f8f8f8; min-width:40px; }
h1 { margin-top:0; }
h2 { margin-top:30px; }
button { padding:8px 12px; margin:4px 6px 10px 0; cursor:pointer; }
textarea { width:360px; height:140px; }
section { margin-bottom:30px; }
#tree-container { border:1px solid #ccc; padding:10px; margin-top:10px; }
svg { width:100%; max-width:900px; height:420px; background:#fafafa; }
.edge { stroke:#bbb; stroke-width:2; }
.node-circle { fill:white; stroke:#555; stroke-width:2; }
.node-text { font-size:12px; dominant-baseline:middle; text-anchor:middle; }
.path-node { fill:#ffe5e5; stroke:#e60000; stroke-width:3; }
.path-edge { stroke:#e60000; stroke-width:3; }
.info { font-size:13px; color:#555; }
.code-input { font-family:monospace; }
</style>
</head>
<body>
<h1>정수 삼각형 DP 시각화</h1>
<p class="info">
백준 &quot;정수 삼각형&quot; 문제에서 사용하는 DP 로직을<br>
<span style="font-weight:bold">2차원 DP / 1차원 DP / 트리 구조 / 최대 경로(빨간색)</span>로 모두 시각화합니다.
</p>

<section>
  <h2>1. 입력 (백준 형식 자동 파싱)</h2>
  <p class="info">
  백준 입력처럼 그대로 붙여넣어도 되고, 첫 줄 없이 삼각형만 적어도 됩니다.<br>
  예)
  </p>
  <pre class="code-input">5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5</pre>
  <textarea id="inputTri" class="code-input">5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5</textarea><br/>
  <button onclick="loadTriangle()">삼각형 적용하기</button>
  <span id="loadStatus" class="info"></span>
</section>

<section>
  <h2>2. 파싱된 삼각형</h2>
  <pre id="triangle"></pre>
</section>

<section>
  <h2>3. 2차원 DP 진행</h2>
  <div id="dp2"></div>
  <button onclick="step2D()">단계 진행</button>
  <button onclick="auto2D()">자동재생 시작/정지</button>
  <button onclick="reset2D()">초기화</button>
</section>

<section>
  <h2>4. 1차원 DP 진행</h2>
  <pre id="dp1"></pre>
  <button onclick="step1D()">단계 진행</button>
  <button onclick="auto1D()">자동재생 시작/정지</button>
  <button onclick="reset1D()">초기화</button>
</section>

<section>
  <h2>5. 트리 형태 시각화 + 최대 경로(빨간색)</h2>
  <p class="info">
    노드 안의 값은 2차원 DP 기준 &quot;해당 위치까지의 최대 합&quot;입니다.<br>
    최대 경로는 <strong>마지막 층에서 가장 큰 값부터 거슬러 올라가며</strong> 찾습니다.
  </p>
  <div id="tree-container">
    <svg id="treeSvg"></svg>
  </div>
  <button onclick="highlightPath()">최대 경로 표시</button>
  <button onclick="clearPath()">경로 강조 지우기</button>
</section>

<script>
let tri = [];
let dp2 = [];
let step2 = 0;
let dp1 = [];
let step1 = 0;
let auto2 = null;
let auto1 = null;
let nodePositions = []; // [i][j] = {x,y}
let pathHighlighted = false;

// ===== 입력 파싱 =====
function parseInput(text){
  const lines = text.trim().split(/\r?\n/).filter(l => l.trim().length>0);
  if (lines.length === 0) return [];

  // 각 줄을 숫자 배열로 변환
  const rows = lines.map(line => line.trim().split(/\s+/).map(Number));
  // 첫 줄이 개수 n만 있는 경우 처리
  if (rows[0].length === 1) {
    const n = rows[0][0];
    const rest = rows.slice(1);
    if (rest.length === n) {
      return rest;
    }
  }
  // 그렇지 않으면 그냥 삼각형 형태라고 가정
  return rows;
}

function loadTriangle(){
  const text = document.getElementById("inputTri").value;
  const parsed = parseInput(text);
  const statusSpan = document.getElementById("loadStatus");

  if (parsed.length === 0) {
    statusSpan.textContent = " 파싱 실패: 입력을 확인해주세요.";
    tri = [];
    dp2 = [];
    dp1 = [];
    renderTriangle();
    render2D();
    render1D();
    renderTree();
    return;
  }

  // 삼각형 형태인지 간단 검증
  let ok = true;
  for (let i=0;i<parsed.length;i++){
    if (parsed[i].length !== i+1){
      ok = false;
      break;
    }
  }
  if (!ok) {
    statusSpan.textContent = " 경고: 각 줄의 원소 개수가 삼각형 형태가 아닙니다.";
  } else {
    statusSpan.textContent = " 파싱 성공!";
  }

  tri = parsed;
  dp2 = Array.from({length:tri.length},()=>[]);
  dp1 = [];
  step2 = 0;
  step1 = 0;
  clearInterval(auto2); auto2=null;
  clearInterval(auto1); auto1=null;
  pathHighlighted = false;

  renderTriangle();
  render2D();
  render1D();
  renderTree();
}

function renderTriangle(){
  const out = tri.map(r => r.join(" ")).join("\n");
  document.getElementById("triangle").textContent = out;
}

// ===== 2차원 DP =====
function render2D() {
  const container = document.getElementById("dp2");
  if (!tri.length) { container.innerHTML = ""; return; }

  let html = "";
  for (let i=0;i<tri.length;i++){
    html += "<div class='grid' style='grid-template-columns:repeat("+(tri[i].length)+",50px)'>";
    for (let j=0;j<tri[i].length;j++){
      let v = (dp2[i] && dp2[i][j] !== undefined) ? dp2[i][j] : "";
      html += "<div class='cell'>" + v + "</div>";
    }
    html += "</div>";
  }
  container.innerHTML = html;

  // DP 값이 바뀔 때마다 트리 노드에도 반영
  updateTreeDP();
}

function step2D(){
  if (!tri.length) return;
  if (step2>=tri.length){ return; }
  const i = step2;
  if (i===0){
    dp2[0][0]=tri[0][0];
  } else {
    for (let j=0;j<=i;j++){
      if (j===0) dp2[i][j]=dp2[i-1][j]+tri[i][j];
      else if (j===i) dp2[i][j]=dp2[i-1][j-1]+tri[i][j];
      else dp2[i][j]=Math.max(dp2[i-1][j-1],dp2[i-1][j])+tri[i][j];
    }
  }
  step2++;
  render2D();
}

function auto2D(){
  if (!tri.length) return;
  if (auto2) { clearInterval(auto2); auto2=null; return; }
  auto2 = setInterval(() => {
    if (step2>=tri.length) {
      clearInterval(auto2); auto2=null;
      return;
    }
    step2D();
  }, 700);
}

function reset2D(){
  if (!tri.length) return;
  dp2 = Array.from({length:tri.length},()=>[]);
  step2 = 0;
  clearInterval(auto2); auto2=null;
  pathHighlighted = false;
  render2D();
  clearPath();
}

// ===== 1차원 DP =====
function render1D(){
  const out = dp1.length ? "["+dp1.join(", ")+"]" : "";
  document.getElementById("dp1").textContent = out;
}

function step1D(){
  if (!tri.length) return;
  if (step1>=tri.length) return;
  const row = tri[step1];

  if (step1===0){
    dp1 = [row[0]];
  } else {
    if (dp1.length < row.length) {
      dp1.push(0);
    }
    for (let j=row.length-1;j>=0;j--){
      if (j===row.length-1){           // 맨 오른쪽
        dp1[j]=(dp1[j-1]||0)+row[j];
      } else if (j===0){               // 맨 왼쪽
        dp1[j]=dp1[j]+row[j];
      } else {                         // 중간
        dp1[j]=Math.max(dp1[j], dp1[j-1]) + row[j];
      }
    }
  }
  step1++;
  render1D();
}

function auto1D(){
  if (!tri.length) return;
  if (auto1) { clearInterval(auto1); auto1=null; return; }
  auto1 = setInterval(() => {
    if (step1>=tri.length){
      clearInterval(auto1); auto1=null;
      return;
    }
    step1D();
  }, 700);
}

function reset1D(){
  dp1 = [];
  step1 = 0;
  clearInterval(auto1); auto1=null;
  render1D();
}

// ===== 트리 시각화 =====
function renderTree(){
  const svg = document.getElementById("treeSvg");
  svg.innerHTML = "";
  nodePositions = [];
  pathHighlighted = false;

  if (!tri.length) return;

  const rows = tri.length;
  const width = svg.clientWidth || 900;
  const height = svg.clientHeight || 420;
  const topMargin = 40;
  const bottomMargin = 40;
  const usableHeight = height - topMargin - bottomMargin;
  const rowGap = rows>1 ? usableHeight / (rows-1) : 0;

  // 노드 좌표 계산
  for (let i=0;i<rows;i++){
    const cols = tri[i].length;
    const rowY = topMargin + i*rowGap;
    nodePositions[i] = [];
    if (cols === 1){
      nodePositions[i][0] = {x: width/2, y: rowY};
    } else {
      const totalWidth = Math.min(width*0.8, cols*70);
      const startX = (width - totalWidth)/2;
      const gap = totalWidth/(cols-1);
      for (let j=0;j<cols;j++){
        nodePositions[i][j] = {x: startX + j*gap, y: rowY};
      }
    }
  }

  // 간선 먼저 그림
  let edgesHTML = "";
  for (let i=0;i<rows-1;i++){
    for (let j=0;j<=i;j++){
      const from = nodePositions[i][j];
      const leftChild = nodePositions[i+1][j];
      const rightChild = nodePositions[i+1][j+1];
      edgesHTML += `<line class="edge" id="edge-${i}-${j}-${i+1}-${j}" x1="${from.x}" y1="${from.y}" x2="${leftChild.x}" y2="${leftChild.y}"></line>`;
      edgesHTML += `<line class="edge" id="edge-${i}-${j}-${i+1}-${j+1}" x1="${from.x}" y1="${from.y}" x2="${rightChild.x}" y2="${rightChild.y}"></line>`;
    }
  }

  // 노드 그림
  let nodesHTML = "";
  for (let i=0;i<rows;i++){
    for (let j=0;j<tri[i].length;j++){
      const p = nodePositions[i][j];
      const idBase = `node-${i}-${j}`;
      nodesHTML += `
        <g id="${idBase}">
          <circle id="${idBase}-circle" class="node-circle" cx="${p.x}" cy="${p.y}" r="18"></circle>
          <text id="${idBase}-text" class="node-text" x="${p.x}" y="${p.y}"></text>
        </g>
      `;
    }
  }

  svg.innerHTML = edgesHTML + nodesHTML;

  // DP 값이 있다면 즉시 반영
  updateTreeDP();
}

function updateTreeDP(){
  if (!tri.length) return;
  for (let i=0;i<tri.length;i++){
    for (let j=0;j<tri[i].length;j++){
      const textEl = document.getElementById(`node-${i}-${j}-text`);
      if (!textEl) continue;
      const v = (dp2[i] && dp2[i][j] !== undefined) ? dp2[i][j] : "";
      textEl.textContent = v;
    }
  }
}

// ===== 최대 경로 강조 =====
function highlightPath(){
  if (!tri.length) return;
  if (!dp2.length || dp2[tri.length-1].length === 0){
    alert("먼저 2차원 DP를 모두 진행해주세요.");
    return;
  }
  if (step2 < tri.length){
    alert("아직 2차원 DP가 모두 계산되지 않았습니다.");
    return;
  }

  clearPath(); // 기존 강조 제거

  const lastRow = tri.length - 1;
  let bestIdx = 0;
  let bestVal = -Infinity;
  for (let j=0;j<dp2[lastRow].length;j++){
    if (dp2[lastRow][j] > bestVal){
      bestVal = dp2[lastRow][j];
      bestIdx = j;
    }
  }

  const path = [];
  let j = bestIdx;
  for (let i=lastRow;i>=0;i--){
    path.push({i, j});
    if (i === 0) break;
    if (j === 0){
      // 무조건 위 (i-1, 0)
    } else if (j === i){
      j = j-1;
    } else {
      if (dp2[i-1][j-1] >= dp2[i-1][j]) j = j-1;
      else j = j;
    }
  }
  path.reverse(); // 위에서 아래로

  // 노드 강조
  for (let k=0;k<path.length;k++){
    const {i, j} = path[k];
    const circle = document.getElementById(`node-${i}-${j}-circle`);
    if (circle){
      circle.classList.add("path-node");
    }
  }

  // 간선 강조 (위->아래 방향으로)
  for (let k=0;k<path.length-1;k++){
    const cur = path[k];
    const next = path[k+1];
    const edgeId = `edge-${cur.i}-${cur.j}-${next.i}-${next.j}`;
    const edge = document.getElementById(edgeId);
    if (edge){
      edge.classList.add("path-edge");
    }
  }

  pathHighlighted = true;
}

function clearPath(){
  // 노드 클래스 제거
  const circles = document.querySelectorAll(".node-circle");
  circles.forEach(c => c.classList.remove("path-node"));
  // 간선 클래스 제거
  const edges = document.querySelectorAll(".edge");
  edges.forEach(e => e.classList.remove("path-edge"));
  pathHighlighted = false;
}

// 초기 로딩 시 기본 예시 파싱
window.addEventListener("load", () => {
  loadTriangle();
});
</script>
</body>
</html>
